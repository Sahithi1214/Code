

public class main{
    public static void main(String[] args) {
        //Problem 1: Two Sum
        // Solution solution = new Solution();
        // int[] nums = {2,7,11,15};
        // int target = 9;
        // int[] result = solution.twoSum(nums, target);
        // System.out.println(Arrays.toString(result));

        //Problem 20: Valid Parentheses
        // Solution solution = new Solution();
        // String s = "()";
        // boolean result = solution.isValid(s);
        // System.out.println(result);

        //Problem 21: Merge Two Sorted Lists
        // Solution solution = new Solution();
        // ListNode l1 = new ListNode(1, new ListNode(2, new ListNode(4)));
        // ListNode l2 = new ListNode(1, new ListNode(3, new ListNode(4)));
        // ListNode result = solution.mergeTwoLists(l1, l2);
        // while(result != null){
        //     System.out.println(result.val);
        //     result = result.next;
        // }

        //Problem 121: Best Time to Buy and Sell Stock
        // Solution solution = new Solution();
        // int[] prices = {7,1,5,3,6,4};
        // int result = solution.maxProfit(prices);
        // System.out.println(result);

        //Problem 125: Valid Palindrome
        // Solution solution = new Solution();
        // String s = "A man, a plan, a canal: Panama";
        // boolean result = solution.isPalindrome(s);
        // System.out.println(result);

        //Problem 226: Invert Binary Tree
        // Solution solution = new Solution();
        // TreeNode root = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(7, new TreeNode(6), new TreeNode(9)));
        // TreeNode result = solution.invertTree(root);
        // System.out.println(result.val);

        //Problem 242: Valid Anagram
        // Solution solution = new Solution();
        // String s = "anagram";
        // String t = "nagaram";
        // boolean result = solution.isAnagram(s, t);
        // System.out.println(result);

        //Problem 704: Binary Search
        // Solution solution = new Solution();
        // int[] nums = {-1,0,3,5,9,12};
        // int target = 9;
        // int result = solution.search(nums, target);
        // System.out.println(result);

        //Problem 733: Flood Fill
        // Solution solution = new Solution();
        // int[][] image = {{1,1,1},{1,1,0},{1,0,1}};
        // int sr = 1;
        // int sc = 1;
        // int newColor = 2;
        // int[][] result = solution.floodFill(image, sr, sc, newColor);
        // System.out.println(Arrays.deepToString(result));
        
        //Problem 235: Lowest Common Ancestor of a Binary Search Tree
        // Solution solution = new Solution();
        // TreeNode root = new TreeNode(6, new TreeNode(2, new TreeNode(0), new TreeNode(4, new TreeNode(3), new TreeNode(5))), new TreeNode(8, new TreeNode(7), new TreeNode(9)));
        // TreeNode p = new TreeNode(2);
        // TreeNode q = new TreeNode(8);
        // TreeNode result = solution.lowestCommonAncestor(root, p, q);
        // System.out.println(result.val);
        
        //Problem 110: Balanced Binary Tree
        // Solution solution = new Solution();
        // TreeNode root = new TreeNode(1, new TreeNode(2, new TreeNode(3), new TreeNode(4)), new TreeNode(2, new TreeNode(4), new TreeNode(3)));
        // boolean result = solution.isBalanced(root);
        // System.out.println(result);

        //Problem 141: Linked List Cycle
        // Solution solution = new Solution();
        // ListNode head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));
        // boolean result = solution.hasCycle(head);
        // System.out.println(result);

        //Problem 232: Implement Queue using Stacks
        // MyQueue queue = new MyQueue();
        // queue.push(1);
        // queue.push(2);
        // System.out.println(queue.peek());
        // System.out.println(queue.pop());
        // System.out.println(queue.empty());

        //Problem 278: First Bad Version
        // Solution solution = new Solution();
        // int n = 5;
        // int result = solution.firstBadVersion(n);
        // System.out.println(result);

        //Problem 383: Ransom Note
        // Solution solution = new Solution();
        // String ransomNote = "a";
        // String magazine = "b";
        // boolean result = solution.canConstruct(ransomNote, magazine);
        // System.out.println(result);

        //Problem 70: Climbing Stairs
        // Solution solution = new Solution();
        // int n = 2;
        // int result = solution.climbStairs(n);
        // System.out.println(result);

        //Problem 409: Longest Palindrome
        // Solution solution = new Solution();
        // String s = "abccccdd";
        // int result = solution.longestPalindrome(s);
        // System.out.println(result);

        //Problem 206: Reverse Linked List
        // Solution solution = new Solution();
        // ListNode head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));
        // ListNode result = solution.reverseList(head);
        // while(result != null){
        //     System.out.println(result.val);
        //     result = result.next;
        // }

        //Problem 169: Majority Element
        // Solution solution = new Solution();
        // int[] nums = {2,2,1,1,1,2,2};
        // int result = solution.majorityElement(nums);s
        // System.out.println(result);

        //Problem 680: Valid Palindrome II
        // Solution solution = new Solution();
        // String s = "abca";
        // boolean result = solution.validPalindrome(s);
        // System.out.println(result);

        //Problem 1570: Sparse Vector Dot Product
        // Solution solution = new Solution();
        // int[] nums1 = {1,0,0,2,3};
        // int[] nums2 = {0,3,0,4,0};
        // SparseVector v1 = new SparseVector(nums1);
        // SparseVector v2 = new SparseVector(nums2);
        // int result = v1.dotProduct(v2);
        // System.out.println(result);

        //Problem 236: Lowest Common Ancestor of a Binary Tree
        // Solution solution = new Solution();
        // TreeNode root = new TreeNode(3, new TreeNode(5, new TreeNode(6), new TreeNode(2, new TreeNode(7), new TreeNode(4))), new TreeNode(1, new TreeNode(0), new TreeNode(8)));
        // TreeNode p = new TreeNode(5);
        // TreeNode q = new TreeNode(1);
        // TreeNode result = solution.lowestCommonAncestor(root, p, q);
        // System.out.println(result.val);

        //Problem 408: Valid Word Abbreviation
        // Solution solution = new Solution();
        // String word = "internationalization";
        // String abbr = "i12iz4n";
        // boolean result = solution.validWordAbbreviation(word, abbr);
        // System.out.println(result);
    }
}